<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Model description</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>In more complex Markov models in health economic evaluation transition probabilities between states can vary with time. These models are called <em>non-homogenous</em> or <em>time-inhomogenous</em> Markov models. A further distinction can be made depending on whether:</p>

<ol>
<li>transition probabilities depend on how long <strong>the entire model</strong> has been running (model-time variation): this situation can be modelled with a non-homogenous Markov model;</li>
<li>transition probabilities depend on how long <strong>an individual</strong> has been in a state (individual-time variation): this situation usually needs to be modelled with a microsimulation.</li>
</ol>

<p>However in some special cases non-homogenous Markov models can be used in situation 2, when the state with transition probabilities depending on individual-time is the starting state <strong>and</strong> it is not possible to go back to that state after having left it. In this situation individual-time is equivalent to model-time. This is the case in the following example.</p>

<p>If you are not familiar with <code>heemod</code>, first consult the introduction vignette<code>vignette(&quot;introduction&quot;, package = &quot;heemod&quot;)</code>.</p>

<h1>Model description</h1>

<p>This example is an implementation of the assessment of a new total hip replacement (THR) technology described in chapter 3.5 of <a href="http://ukcatalogue.oup.com/product/9780198526629.do">Decision Modelling for Health Economic Evaluation</a>. A more detailed report is available <a href="https://www.york.ac.uk/media/che/documents/papers/technicalpapers/CHE%20Technical%20Paper%2028.pdf">at this location</a>, event though this reports goes a bit further in the analysis.</p>

<p>This model has 5 states:</p>

<ul>
<li>Primary THR: starting state, individuals receive either the standard or the new THR (called NP1), outcomes are either success of primary THR or death (the operative mortality rate of primary THR will be called <code>omrPTHR</code>);</li>
<li>Success of primary THR: state after receiving primary THR if the surgery is successfull, individuals can stay in this state, need a THR revision, or die of other causes;</li>
<li>Revision of primary THR: for individuals whose primary THR needed revision, outcomes are either success of revision THR or death (the operative mortality rate of revision THR will be called <code>omrRTHR</code>);</li>
<li>Success of revision THR: state after receiving revision THR if the surgery is successfull, individuals can stay in this state, need a THR re-revision, or die of other causes;</li>
<li>Death (either caused by THR or another cause).</li>
</ul>

<p>Two transition probabilities are time-varying in this model:</p>

<ul>
<li>Probability of death by another cause increases with age;</li>
<li>Probability of primary THR revision increases with time.</li>
</ul>

<p>Other-cause death probabilities (mortality rate <code>mr</code>) vary with age and gender with the following values:</p>

<pre><code class="r">death_prob &lt;- data.frame(
  age = rep(seq(35, 85, 10), each = 2),
  sex = rep(0:1, 6),
  mr = c(
    1.51e-3, .99e-3, 3.93e-3,
    2.6e-3, 10.9e-3, 6.7e-3,
    31.6e-3, 19.3e-3, 80.1e-3,
    53.5e-3, 187.9e-3, 154.8e-3
  )
)
death_prob
</code></pre>

<pre><code>##    age sex      mr
## 1   35   0 0.00151
## 2   35   1 0.00099
## 3   45   0 0.00393
## 4   45   1 0.00260
## 5   55   0 0.01090
## 6   55   1 0.00670
## 7   65   0 0.03160
## 8   65   1 0.01930
## 9   75   0 0.08010
## 10  75   1 0.05350
## 11  85   0 0.18790
## 12  85   1 0.15480
</code></pre>

<p>Primary THR revision probability increases with time with the following formula (a Weibull distribution):</p>

<p>\[
P_{revision} = 1 - \exp(\lambda \times ((t-1)^\gamma-t^\gamma))
\]</p>

<p>Where \(t\) is the time since revision, \(\gamma = 1.45367786\) and:</p>

<p>\[
\lambda = exp(cons + ageC \times age + maleC \times sex)
\]</p>

<p>Where <code>age</code> and <code>sex</code> (female = 0, male = 1) are individual characteristics, <code>cons</code> = -5.49094, <code>ageC</code> = -0.0367 and <code>maleC</code> = 0.768536.</p>

<p>For the NP1 procedure the revision probability is modified by the relative risk <code>rrNP1</code> = 0.260677.</p>

<p>\[
P_{revision} = 1 - \exp(\lambda \times rrNP1 \times ((t-1)^\gamma-t^\gamma))
\]</p>

<p>Revision THR re-revision (<code>rrr</code>) probability is set to be constant at 0.04 per year.</p>

<h1>Parameters definition</h1>

<p>The key element to specify time-varying elements in <code>heemod</code> is through the use of a package-defined variable, <code>markov_model</code>. This variable takes increasing values with each cycles, starting from 1. For example the age of individuals at any moment can be defined as <code>Initial age + markov_cycle</code>.</p>

<p>In order to build this more complex Markov model, parameters need to be defined through <code>define_parameters</code>. The equations decribed in the previous section can be written easily, here for a female population (<code>sex</code> = 0) starting at 60 years old (<code>age_init</code> = 60):</p>

<pre><code class="r"># a function to return mr, given age and sex
mr_func &lt;- function(age, sex) {
  age  &lt;- floor(age/10-.5)*10+5
  age &lt;- ifelse(age &gt; 85, 85, age)
  merge(data.frame(age = age, sex = sex), death_prob)$mr
}
param_standard &lt;- define_parameters(
    t = markov_cycle,

    age_init = 60,
    sex = 0,
    age = age_init + t,

    omrPTHR = .02,
    omrRTHR = .02,
    rrr = .04,

    cons = -5.49094,
    ageC = -.0367,
    maleC = .768536,
    lambda = exp(cons+ageC*age_init+maleC*sex),
    gamma = 1.45367786,

    rrNP1 = .260677,

    standardRR = 1 - exp(lambda*((t-1)^gamma-t^gamma)),

    mr = mr_func(age, sex)
)
param_standard
</code></pre>

<pre><code>## 15 unevaluated parameters.
## 
## t = markov_cycle
## age_init = 60
## sex = 0
## age = age_init + t
## omrPTHR = 0.02
## omrRTHR = 0.02
## rrr = 0.04
## cons = -5.49094
## ageC = -0.0367
## maleC = 0.768536
## lambda = exp(cons + ageC * age_init + maleC * sex)
## gamma = 1.45367786
## rrNP1 = 0.260677
## standardRR = 1 - exp(lambda * ((t - 1)^gamma - t^gamma))
## mr = mr_func(age, sex)
</code></pre>

<p>The parameters for the NP1 group are almost the same as for the standard group, with the exception of the primary THR revision probability formula. Parameters can by modified through the function <code>modify</code>:</p>

<pre><code class="r">param_np1 &lt;- modify(
  param_standard,
  standardRR = 1 - exp(lambda*rrNP1*((t-1)^gamma-t^gamma))
)
param_np1
</code></pre>

<pre><code>## 15 unevaluated parameters.
## 
## t = markov_cycle
## age_init = 60
## sex = 0
## age = age_init + t
## omrPTHR = 0.02
## omrRTHR = 0.02
## rrr = 0.04
## cons = -5.49094
## ageC = -0.0367
## maleC = 0.768536
## lambda = exp(cons + ageC * age_init + maleC * sex)
## gamma = 1.45367786
## rrNP1 = 0.260677
## standardRR = 1 - exp(lambda * rrNP1 * ((t - 1)^gamma - t^gamma))
## mr = mr_func(age, sex)
</code></pre>

<h1>Transition matrix definition</h1>

<p>Now that parameters are defined, the probability transitions can be easily written:</p>

<pre><code class="r">mat_trans &lt;- define_matrix(
    state_names = c(
      &quot;PrimaryTHR&quot;,
      &quot;SuccessP&quot;,
      &quot;RevisionTHR&quot;,
      &quot;SuccessR&quot;,
      &quot;Death&quot;
    ),
    0, 1-omrPTHR,         0,          0,          omrPTHR,
    0, 1-(standardRR+mr), standardRR, 0,          mr,
    0, 0,                 0, 1-(omrRTHR+mr), omrRTHR+mr,
    0, 0,                 rrr,        1-(mr+rrr), mr,
    0, 0,                 0,          0,          1
)
mat_trans
</code></pre>

<pre><code>## An unevaluated matrix, 5 states.
## 
##             PrimaryTHR SuccessP              RevisionTHR
## PrimaryTHR  0          1 - omrPTHR           0          
## SuccessP    0          1 - (standardRR + mr) standardRR 
## RevisionTHR 0          0                     0          
## SuccessR    0          0                     rrr        
## Death       0          0                     0          
##             SuccessR           Death       
## PrimaryTHR  0                  omrPTHR     
## SuccessP    0                  mr          
## RevisionTHR 1 - (omrRTHR + mr) omrRTHR + mr
## SuccessR    1 - (mr + rrr)     mr          
## Death       0                  1
</code></pre>

<h1>State definition</h1>

<p>Utilities and costs are then associated to states. In this model costs are discounted at a rate of 6% and utilities at a rate of 1.5%.</p>

<pre><code class="r">state_list &lt;- define_state_list(
    PrimaryTHR = define_state(
      utility = 0,
      cost = 0
    ),
    SuccessP = define_state(
      utility = discount(.85, .015),
      cost = 0
    ),
    RevisionTHR = define_state(
      utility = discount(.30, .015),
      cost = discount(5294, .06)
    ),
    SuccessR = define_state(
      utility = discount(.75, .015),
      cost = 0
    ),
    Death = define_state(
      utility = 0,
      cost = 0
    )
  )
state_list
</code></pre>

<pre><code>## A list of 5 unevaluated states with 2 values each.
## 
## State names:
## 
## PrimaryTHR
## SuccessP
## RevisionTHR
## SuccessR
## Death
## 
## State values:
## 
## utility
## cost
</code></pre>

<h1>Model definition</h1>

<p>Now that parameters, transition matrix and states are defined we can define the models for the control group and the NP1 treatment:</p>

<pre><code class="r">mod_standard &lt;- define_model(
  parameters = param_standard,
  transition_matrix = mat_trans,
  states = state_list
)
mod_standard
</code></pre>

<pre><code>## An unevaluated Markov model:
## 
##     15 parameters,
##     5 states,
##     2 state values.
</code></pre>

<pre><code class="r">mod_np1 &lt;- define_model(
  parameters = param_np1,
  transition_matrix = mat_trans,
  states = state_list
)
</code></pre>

<h1>Analyse models</h1>

<p>Both models can now be run for 60 years, for 1 person starting in <code>PrimaryTHR</code>:</p>

<pre><code class="r">res_mod &lt;- run_models(
  standard = mod_standard,
  np1 = mod_np1,
  cycles = 60
)
res_mod
</code></pre>

<pre><code>## 2 Markov models, run for 60 cycles.
## 
## Model names:
## 
## standard
## np1
</code></pre>

<p>A comparison of both models can be done with <code>summary</code>:</p>

<pre><code class="r">summary(res_mod)
</code></pre>

<pre><code>## 2 Markov models run for 60 cycles.
## 
## Initial states:
## 
##             N
## PrimaryTHR  1
## SuccessP    0
## RevisionTHR 0
## SuccessR    0
## Death       0
##           utility      cost
## standard 14.67977 221.95698
## np1      14.72271  58.89669
</code></pre>

<p>Since standard treatment costs 394 and NP1 costs 579, the ICER for a population of women aged 60 can be calculated with the following formula:</p>

<p>\[
\frac{(58.90 + 579) - (221.96 + 394)}{14.72 - 14.68} = 548.5
\]</p>

<p>The new treatment costs 548.5 GBP per QALY gained.</p>

</body>

</html>
